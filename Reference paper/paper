
毕业设计（论文）


题    目：基于K-Means的空间聚类算法研究与实现
专    业：         计算机科学专业              
学    生：             赵朝华                  
学    号：         222010326022014             
指导教师：             伍 胜                   





2014年5月12日
 
目录
摘要	1
1 绪论	2
2 研究方法综述	2
2.1 空间数据的复杂性	2
2.2 空间聚类数据的要求	3
2.3 聚类算法	4
2.4 空间聚类算法	7
2.5 K-MEANS空间聚类算法	10
3 相关技术介绍	14
3.1 JAVA程序设计语言	14
3.2 APACHE ANT工具介绍	15
3.3 JAVA SWING工具介绍	16
4 问题分析	16
5 算法设计及实现	17
5.1 算法描述和实现策略	17
5.2 应用的模块设计	17
5.3 算法及代码实现	18
5.4 界面设计显示	27
6 总结与展望	28
6.1总结	28
6.2展望	28
参考文献	29
致谢	29

 
基于K-Means的空间聚类算法研究与实现
赵朝华
西南大学计算机与信息科学学院，重庆  400715
摘要：聚类作为数据挖掘的一个重要的研究领域，倍受关注。不同类型的聚类算法可以分成不同的类别。聚类算法可分为划分方法与层次方法两大类。划分方法有：K-Means算法、K-MEDOIDS算法、 CLARANS算法。层次方法有：BIRCH算法、CURE算法、CHAMELEON算法。本文主要讲述了K-means算法的原理、方法和在土壤选点中应用。
其中先讲到了聚类算法中使用的基础性知识和K-Means算法的基本概念和流程，再具体讲述了怎么使用K-Means算法对空间里的点集进行聚类。然后根据K-means算法实现代码，用土壤数据测试算法。
关键字：聚类；K-均值；土壤选点
Analysis of spatial clustering algorithm based on K-means 
Zhao Chao-hua
The school of Computer and Information Science, Southwest University,Chongqing 400715,China
Abstract：Clustering, an essential field of data mining, attracted much attention. Different types of clustering algorithms can be divided into different categories. Clustering and hierarchical classification method can be divided into two categories methods: division methods, including K-Means algorithm, K-MEDOIDS algorithm, CLARANS algorithm, and hierarchical methods, consisting of BIRCH algorithm, CURE algorithm, CHAMELEON algorithm. This paper focuses on the theory, methods and applications selecting points in soil of K-means algorithm.
	This paper first talks about the basis of knowledge on clustering algorithm and the basic concepts and processes used in K-Means algorithm, and then it tells about how to use K-Means algorithm to cluster for point set in the plane in detail. Lastly implement the code based on K-means algorithm, and use soil data to test algorithms.
Key word：Clustering;K-means;selecting points in soil
1 绪论
面对信息技术的日新月异，人们利用信息技术生产和搜集数据的能力大幅度提高，大量的数据库被用于商业管理、政府办公、科学研究和工程开发等，数据挖掘和知识发现技术应运而生，蓬勃发展，越来越显示出气强大的生命力。
数据挖掘(Data Mining)就是从大量的、不完全的、有噪声的、模糊的、随机的数据中，提取隐含在其中的、人们事先不知道的、但又潜在有用的信息和知识的过程。人们把原始数据看作是形成知识的源泉，就像从矿石中采矿一样[1]。原始数据可以是结构化的形式，如关系数据库中的数据，也可以使半结构化的形式，比如文本、图形、图像数据，或者甚至可以是分布在网络中的异构型数据。并且发现数据的方法可以是数学的，也可以是非数学的；可以使演绎的，也可以是归纳的。挖掘出的数据知识可以是被用于查询优化、信息管理、决策支持和过程控制等等，还可以用于数据自身的维护。
聚类分析作为数据挖掘和统计学的一个分支，其主要是基于距离的聚类分析，应用十分广泛。本文主要将聚类分析应用在土壤样品选点中，不同地区土壤的色泽、土质、酸碱度、肥力和粘化性不同，因而可以选择出不同类别的土壤，帮助耕种者种植不同的作物，因地制宜，提升作物产量和作物品质，从而对提高经济效益具有十分重要的意义。
2 研究方法综述
2.1 空间数据的复杂性
空间聚类分析的对象是空间数据。由于空间数据具有空间实体的位置、大小、形状、方位及几何拓扑关系等信息，使得空间数据的存储结构和表现形式比传统事务型数据更为复杂，空间数据的复杂特性表现如下：
(1)空间属性间的非线性关系。由于空间数据中蕴含着复杂的拓扑关系，因此，空间属性间呈现出一种非线性关系。这种非线性关系不仅是空间数据挖掘中需要进一步研究的问题，也是空间聚类所面临的难点之一。
(2)空间数据的尺度特征。空间数据的尺度特征是指在不同的层次上，空间数据所表现出来的特征和规律都不尽相同。虽然在空间信息的概化和细化过程中可以利用此特征发现整体和局部的不同特点，但对空间聚类任务来说，实际上是增加了空间聚类的难度。
(3)空间信息的模糊性。空间信息的模糊性是指各种类型的空间信息中，包含大量的模糊信息，如空间位置、空间关系的模糊性，这种特性最终会导致空间聚类结果的不确定性。
(4)空间数据的高维度。空间数据的高维度性是指空间数据的属性(包括空间属性和非空间属性）个数迅速增加，比如在遥感领域，获取的空间数据的维度已经快速增加到几十甚至上百个，这会给空间聚类的研究增加很大的困难。
2.2 空间聚类数据的要求
(1) 可伸缩性；许多聚类算法在小于 200 个数据对象的小数据集合上工作得很好；但是，一个大规模数据库可能包含几百万个对象，在这样的大数据集合样本上进行聚类可能会导致有偏的结果。我们需要具有高度可伸缩性的聚类算法。
(2) 发现任意形状的聚类；许多聚类算法基于欧几里得或者曼哈顿距离度量来决定聚类。基于这样的距离度量的算法趋向于发现具有相近尺度和密度的球状簇。但是，一个簇可能是任意形状的。提出能发现任意形状簇的算法是很重要的。（虽然聚类分析属于非监督学习方法，但在某些情况下一些基本的客观规律也会或多或少指示聚类分析的结果）
(3) 用于决定输入参数的领域知识最小化；许多聚类算法在聚类分析中要求用户输入一定的参数，例如希望产生的簇的数目。聚类结果对于输入参数十分敏感。参数通常很难确定，特别是对于包含高维对象的数据集来说。这样不仅加重了用户的负担，也使得聚类的质量难以控制。
(4) 对噪声数据不敏感；绝大多数现实中的数据库都包含了孤立点，缺失，或者错误的数据。一些聚类算法对于这样的数据敏感，可能导致低质量的聚类结果。
(5) 对于输入记录的顺序不敏感；一些聚类算法对于输入数据的顺序是敏感的。例如，同一个数据集合，当以不同的顺序交给同一个算法时，可能生成差别很大的聚类结果。开发对数据输入顺序不敏感的算法具有重要的意义。
(6) 处理高维数据；一个数据库或者数据仓库可能包含若干维或者属性。许多聚类算法擅长处理低维的数据，可能只涉及两到三维。人类的眼睛在最多三维的情况下能够很好地判断聚类的质量。在高维空间中聚类数据对象是非常有挑战性的，特别是考虑到这样的数据可能分布非常稀疏，而且高度偏斜。
2.3 聚类算法
	聚类算法是在预先不知道目标数据库到底有多少类的情况下，希望自己希望自己所有的记录组成不同的类或者聚类，并且使得在这种分类情况下，以某种度量为标准的相似性，在同一聚类之间最小化，而在不同聚类之间最大化。
2.3.1 聚类的一般步骤
	第一部是特征提取。它的输入是原始样本，由领域专家决定使用哪些特征来深刻地刻画样本性质和结构。特征提取的结果是输出一个矩阵，每一行是一个样本，每一列是一个特征指标变量。在选取过程中，选取特征的优劣将直接影响以后分析和决策。如果第一步就选取了与聚类意图毫不相干的特征变量，则不能得到良好的聚类结果。因为无论后续步骤采用多么优良聚类算法和阈值选择方案，都不能计算出执行者的意图。而合理的特征选取方案应当使得同类样本在特征空间中相距较近，异类样本则相距较远。
	第二步是执行聚类算法，获得聚类谱系图。聚类的输入时一个样本矩阵，它把一个样本想象成为特征标量空间中的点。聚类算法的目的是获得能够反映N维空间中这些样本点的最本质的“簇”的性质。这一步无需领域专家的参与，它除了集合知识外，不考虑特征变量在其领域中的特定含义，仅仅认为它是特征空间中的一维而已。聚类算法的输入一般是一个聚类谱系图，由粗到细地反映了所有的分类情况或者直接给出分类方案，包括分为几类，每类包含哪些特征点等等。
	第三步是选取合适的分类阈值。在得到聚类谱系图后，领域专家凭借经验和领域知识，根据具体的应用场合，决定阈值的选取。选定阈值以后，就能够从聚类谱系图中直接看出分类方案。没有领域专家的参与，不考虑具体的应用背景，而仅仅依赖从聚类谱系图出发寻找聚类指数的突变点或者求最小生成树的长边等等，往往不会得到满意的结果。领域专家还可以对聚类结果结合领域知识进行进一步的分析，从而加深样本点和特征变量的认识。如图2-1所示，一个聚类算法所遵循的一般过程如下：
 
图 2-1 一个聚类算法遵循的一般过程
2.3.2 聚类分析中相似性度量
对于特性的聚类问题，一个算法产生的簇集可能有许多性质，最重要的一条性质就是“较高的簇内相似性，较低的簇间相似性”。所有说一个聚类问题中相似性度量的选择是非常重要的。
2.3.3.1元组之间的相似性度量方法
因为相似性是一个簇的定义中最基础的部分，所有对于大部分的聚类问题来说，同一个特征空间中两个元组之间的相似性度量也是至关重要的。现实中比较常用的是通过距离来计算两个元组之间的相异性。
在聚类问题中，使用符号 来表示两个元组 之间的相似性度量。首先给出一个关于相似性度量和聚类问题的概念如下：
给定由一些元组组成的数据库 以及两个元组 之间的相似性度量 和整数值k，则聚类问题就是定义一个映射 ，其中第 个元组被映射到第 个簇 中去， 。给定簇 ，对于 和 ，有 。
距离度量 与相似性度量的含义相反，但在聚类中经常被使用。数值属性的相似性测量方法大多直接或间接依赖于欧几里德距离。常见的基于欧氏距离的聚类算法有分割算法中的K-Means算法以及分层算法中的BIRCH算法，CURE算法以及基于密度的DBSCAN算法。下面给出聚类问题中常用的一些计算元组之间距离的距离度量：
欧氏距离：
               (公式2.1)
明氏距离：
               (公式2.2)
马氏距离：
          (公式2.3)
其中，欧氏距离是明氏距离当p=2时的一种特殊情况，而马氏距离中的 代表元组之间的协方差矩阵。欧式距离是聚类问题中经常被使用的一种距离度量。有时为了突出一些数据的关键属性对聚类分析的重要作用，常采用加权形式的距离，以避免某些属性的值过大而屏蔽其它取值较小的属性对数据相似性测量的影响。
2.3.3 聚类的应用
	聚类已经被广泛应用于许多领域，例如生物学、药学、人类学、市场营销和经济学。聚类应用包括动植物分类、疾病分类、图像处理、模式识别和文本检索。例如，在商业方面，聚类分析可以帮助市场人员发现顾客群中所存在的不同特征的群组，并可以利用购买模式来描述这些具有不同特征的顾客组群。在生物学方面，聚类分析可以用来获取动物或植物所存在的层次结构，可根据基因功能对其进行分类以获得对人群中所固有的结构更深入的了解。聚类还可以从地球观测数据库中帮助识别具有相似的土地使用情况的区域，此外，还可以帮助分类识别互联网上的文档以便进行信息发现。
2.4 空间聚类算法
聚类作为数据挖掘的一个重要的研究领域，倍受关注[2]。聚类被称为无监督分类，即我们事先对数据集的分布没有任何的了解，它是将物理或抽象对象的集合组成为由类似的对象组成的多个类的过程。聚类方法作为一类非常重要的数据挖掘技术，其主要是依据样本间相似性的度量标准将数据集自动分成几个群组，且使同一个群组内的样本之间相似度尽量高，而属于不同群组的样本之间相似度尽量低的一种方法。聚类中的组不是预先定义的，而是根据实际数据的特征按照数据之间的相似性来定义的，聚类中的组也称为簇。一个聚类分析系统的输入是一组样本和一个度量样本间相似度(或距离)的标准，而输出则是簇集，即数据集的几个类，这些类构成一个分区或者分区结构。聚类分析的一个附加的结果是对每个类的综合描述，这种结果对于更进一步深入分析数据集的特性是尤其重要的。聚类方法尤其适合用来讨论样本间的相互关联从而对一个样本结构做一个初步的评价。数据挖掘中的聚类研究主要集中在针对海量数据的有效和实用的聚类方法上，聚类方法的可伸缩性、高维聚类分析、分类属性数据聚类、具有混合属性数据的聚类和非距离模糊聚类等问题是目前数据挖掘研究人员最为感兴趣的[3]。
目前，研究人员已经对空间聚类问题进行了较为深入的研究，提出了多种算法[4]。根据空间聚类采用的不同思想，空间聚类算法主要可归纳为以下几种：基于划分的聚类算法、基于层次的聚类算法、基于密度的聚类算法、基于网格的聚类算法、基于模型的聚类算法以及其它形式的聚类算法，其关系如树形图图2-2 所示:
 图 2-2 空间聚类算法分类
(1) 基于划分的聚类
基于划分的聚类方法是最早出现并被经常使用的经典聚类算法。其基本思想是：在给定的数据集随机抽取n个元组作为n个聚类的初始中心点，然后通过不断计算其它数据与这几个中心点的距离(比如欧几里得距离)，将每个元组划分到其距离最近的分组中，从而完成聚类的划分。由于基于划分的聚类方法比较容易理解，且易实现，目前其已被广泛的弓l入到空间聚类中，用于空间数据的分类。包括K—均值法、K—中心点法和EM聚类法。它们都是采用一种迭代的重定位技术尝试通过对象在划分间移动来改进聚类效果。由于这类方法适用于发现大小相近的球状簇，故常用在设施选址等应用中。
(2) 基于层次的聚类
基于层次的聚类方法就是将数据对象组成一棵聚类的树。根据层次的分解方向，分为凝聚法和分裂法。凝聚法最初假定数据集中的每个对象都为一个单独的类，然后通过不断合并相近的对象，直到满足条件为止；分裂法同凝聚法的分解方向相反，其开始假设所有的对象都在一个类中，之后不断进行分裂，直到满足条件为止。由于一个类一旦分裂或凝聚就不能撤消，因此基于层次的算法的灵活性较差，故很少有纯粹的层次算法，层次方法往往和其它方法相结合进行聚类。此法只是对对象集合进行分解。根据层次的分解方式,这类方法可分为凝聚和分裂两种， Birch，Cure 和Chameleon是上述方法的改进。
(3) 基于密度的聚类
基于密度的聚类算法主要特点在于其使用区域密度作为划分聚类的依据，其认为只要数据空间区域的密度超过了预先定义的阀值，就将其添加到相近的聚类中。这种方法不同于各种各样基于距离的聚类算法，其优点在于能够发现任意形状的聚类，从而克服基于距离的方法只能发现类圆形聚类的缺点。对给定类中的每个数据点,在一个给定范围的区域中必须包含超过某个阈值的数据点，才继续聚类。它可以用来发现任意形状的簇，过滤“噪声”。代表性的方法有：DBSCAN，Optics和Denclue。 
(4) 基于网格的聚类
主要思想是将空间区域划分若干个具有层次结构的矩形单元，不同层次的单元对应于不同的分辨率网格，把数据集中的所有数据都映射到不同的单元网格中，算法所有的处理都是以单个单元网格为对象，其处理速度要远比以元组为处理对象的效率要高的多。常用的方法有STING、WaveCluster以及CLIQUE等。
(5) 基于模型的聚类
基于模型的聚类主要思想是假设数据集中的数据分布符合特定的数学模型，通过数学模型来发现聚类。主要有两种基于模型的方法：一种是统计学的方法，代表性算法是COBWEB算法；另一种是神经网络的方法，代表性的算法是竞争学习算法。COBWEB 算法是一种增量概念聚类算法。这种算法不同于传统的聚类方法，它的聚类过程分为两步：首先进行聚类，然后给出特征描述。因此，分类质量不再是单个对象的函数，而且也加入了对聚类结果的特征性描述。竞争学习算法[5]属于神经网络聚类。它采用若干个单元的层次结构，以一种“胜者全取”的方式对系统当前所处理的对象进行竞争[6]。
在这些方法中，基于划分的k-均值算法和基于密度的DBSCAN算法是两种基础而应用十分广泛的聚类分析方法，本文主要介绍k-均值算法研究及应用。
2.5 K-means空间聚类算法
	K-means算法，也被称为K-平均或K-均值，是一种目前得到最广泛运用的聚类算法，是一种在无类标号数据中发现簇和簇中心的方法。
2.5.1 K-means算法的基本原理
它的基本思想是：给定一个包含n个数据对象的数据库，以及要生成簇的数目K，随机选取K个对象作为初始的K个聚类中心；然后计算剩余各个样本到每一个聚类中心的距离，把该样本归到离它最近的那个聚类中心所在的类，对调整后的新类使用平均值的方法计算新的聚类中心；如果相邻两次的聚类中心没有任何变化，说明样本调整结束且聚类平均误差准则函数已经收敛。可见，本算法在每次迭代中都要考察每个样本的分类是否正确，若不正确，就要调整，在全部样本调整完后，修改聚类中心，进入下一次迭代。如果在一次迭代算法中，所有的样本被正确分类，则不会有调整，聚类中心不会有变化。在算法迭代巾值在不断减小，最终收敛至一个固定的值。这一算法不适合于处理离散型属性，但是对于对于连续型具有较好的聚类效果[7]。
2.5.2 K-means聚类算法处理过程
输入: 簇的数目k 和包含n 个对象的数据库。
输出: k 个簇, 使平方误差准则最小。
方法：首先从n个数据对象任意选择k个对象作为初始聚类中心，而对于所剩下的其它对象，则根据它们与这些聚类中心的相似度（距离），分别将它们分配给与其最相似的（聚类中心所代表的）聚类。然后，再计算每个所获新聚类的聚类中心（该聚类中所有对象的均值），不断重复这一过程直到标准测度函数开始收敛为止。
(1) 任意选择k 个对象作为初始的簇中心。算法开始，输入N个数据对象，对于本文来说，N个数据对象就是要进行聚类的N个平面上的点，即输入N个点的坐标值（x,y）并存储。确定要生成的聚类个数K，即要将平面上的N个点分成K类，输入K并存储。
(2) 分别计算每个对象到各个聚类中心的距离，把对象分配到距离最近的聚类中。在输入的N个数据对象中，随机选择K个数据对象，并记录。这K个数据对象将作为初始的聚类中心。要求：K≤N。分配时，计算个数据对象的相似度，划分到最近的聚类中心去。
(3) 所有对象分配完成后，重新计算k个聚类的中心。
(4) 与前一次计算得到的k个聚类中心比较，如果聚类中心发生变化，转至(2)，否则转(5)。
(5) 输出聚类结果。
实现的流程框图为：
开始
绘制原始数据图
输入聚类个数k
和迭代次数
执行
初始化k个聚类中心
分配各数据对象到距离最近的类中
                重新计算各个聚类的中心              否

E是否收敛

  是
输出聚类结果

接受并可视化显示
结束
图2-3 k-means算法处理流程
由上可知，K-means算法的两个核心问题：
度量记录之间的相关性的计算公式，常采用欧式距离，其定义如下：
假设给定的数据集X={xm|m=1,2,……total}，X中的样本用d个描述属性A1,A2…Ad来表示，并且d个描述属性都是连续型属性。数据样本xi=(xi1,xi2,…xid), xj=(xj1,xj2,…xjd)其中， xi1,xi2,…xid和xj1,xj2,…xjd分别是样本xi和xj对应d个描述属性A1,A2…Ad的具体取值。样本xi和xj之间的相似度通常用它们之间的距离d(xi,xj)来表示，距离越小，样本xi和xj越相似，差异度越小；距离越大，样本xi和xj越不相似，差异度越大。其距离公式如公式2-1。
(2) 选择评价聚类性能的准则函数，使用误差平方和准则函数来评价聚类性能。其定义如下：给定数据集X，其中只包含描述属性，不包含类别属性。假设X包含k个聚类子集X1,X2,…XK；各个聚类子集中的样本数量分别为n1，n2,…,nk;各个聚类子集的均值代表点（也称聚类中心）分别为m1，m2,…,mk。则误差平方和准则函数公式为：
																	(公式2-4)
其中E为数据库中所有对象的均方差之和，p为代表对象的空间中的一个点，mi为聚类Ci的均值(p和mi均是多维的)。该公式所示的聚类标准，旨在使所获得的k个聚类具有以下特点：各聚类本身尽可能的紧凑，而各聚类之间尽可能的分开。
2.5.3 k-means的算法实现
	输入n个数据对象集合Xi，输出k个聚类中心Zj以及K个数据对象集合Cj。
Procedure k-means(s,k)
S=(x1,x2……xn);
m=1; for j=1 to k 初始化聚类中心Zj；
do {for i= 1 to n
		for j= 1 to k
			{D(Xi,Zj)=|Xi-Zj |; if D(Xi,Zj)=min}{D(Xi,Zj)} then Xi∈Cj;}//归类
		If m=1 then Jc(m)=Σkj=Σ|Xi-Zj|2
m=m+1; for j=1 to k
Zj=(Σ(Xi)j)/n; //重置聚类中心
}while |Jc(m)-Jc(m-1)|>δ
2.5.4 k-means算法的性能分析
主要优点：(1) 是解决聚类问题的一种经典算法，简单、快速；(2) 对处理大数据集，该算法是相对可伸缩和高效率的。因为它的复杂度是0 (n k t ) , 其中, n 是所有对象的数目, k 是簇的数目, t 是迭代的次数。通常k < <n 且t < <n；(3) 当结果簇是密集的，而簇与簇之间区别明显时, 它的效果较好。主要缺点：(1) 在簇的平均值被定义的情况下才能使用，这对于处理符号属性的数据不适用；(2) 必须事先给出k（要生成的簇的数目），而且对初值敏感，对于不同的初始值，可能会导致不同结果；(3) 它对于“躁声”和孤立点数据是敏感的，少量的该类数据能够对平均值产生极大的影响。
3 相关技术介绍
3.1 java程序设计语言
3.1.1 java语言简介
	Java是一种可以撰写跨平台应用软件的面向对象的程序设计语言，是Sun Microsystem公司研究开发的一种新型的程序设计语言。Java起源于1994年，美国Sun Microsystem的Patrick Nawghton、Jame Gosling和Mike Sheridan等人组成的开发小组，开始了代号为Green的项目的研制，其目标是研制一种开发家用电器的逻辑控制系统，产品名称为Oak。1995年1月，Oak被更名为Java。这个名字来自于印度尼西亚的一个盛产咖啡的小岛的名字，小岛的中文名叫爪哇。正是因为许多程序设计师从钟爱的热腾腾的香浓咖啡中得到灵感，因而热腾腾的香浓咖啡也就成为Java语言的标志。随着Internet的飞速发展，人们的学习、工作、科研、商业和生活方式随之发生了巨大变化。人们不仅需要具有声音、图像和动画等多媒体信息的Web页面，以及实时视频、多用户网络游戏等，而且要求能向用户提供更好的实时交互性，并具有平台无关性。Java的出现，使人们看到了解决以上问题的希望。Java之所以能解决这些问题是与其自身的特点分不开的。Java具有如下特点：(1)简单性；(2)平台无关性；(3)分布式；(4)健壮性；(5)安全性；(6)浏览器应用。 
3.1.2 java的运行机制
虽然Java常用作开发各种应用程序的编程语言，但是作为编程语言只是Java的众多用途之一，而真正形成Java众多优点（包括平台独立性）的是其底层架构。完整的Java体系结构实际上是由4个组件组合而成：Java编程语言、Java类文件格式、Java API和JVM。 	其中，JVM是Java Virtual Machine（Java虚拟机）的缩写，它是一个虚构出来的计算机。它是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。因此，使用Java开发时，本质就是用Java编程语言编写代码，然后将代码编译为Java类文件，接着在JVM中执行类文件。其运行结构如下图：
  
3.2 Apache ant工具介绍
	Apache ant是一个将软件编译、测试、部署等步骤联系在一起加以自动化的一个工具，大多用于java环境中的软件开发。当开始一个新项目时，首先应该编写Ant构建文件，构建文件定义了构建过程，并被团队开发中每个人使用。构建文件可以放在任何位置，一般是放在项目顶层文件中。一个典型的项目层次结构如下：(1)src存放文件；(2)class存放编译后的文件；(3)lib存放第三方JAR包；(4)dist存放打包，发布后的代码。Ant是Apache软件基金会JAKARIA目录中的一个子项目，具有以下优点：(1)跨平台性，Ant是由java语言编写的，所以具有很好的跨平台性；(2)操作简单，Ant是由一个内置任务和可选任务组成的，运行时需要一个XML文件（构建文件），Ant通过调用target树，就可以执行各种task。由于Ant的跨平台性和操作简单的特点，它很容易集成到一些开发环境中去。
3.3 Java swing工具介绍
	Java swing是一个用于开发Java应用程序用户界面的开发工具包，它以抽象窗口工具包（AWT）为基础使跨平台应用程序可以使用任何可插拔的外观风格。Swing开发人员只用很少的代码就可以利用Swing丰富、灵活的功能和模块化组件来创建优雅的用户界面。用Swing创建图形界面步骤：(1)导入Swing包；(2)选择界面风格；(3)设置顶层容器，顶层Swing容器为其他Swing组件在屏幕上的绘制和处理事件提供支持；(4)设置按钮和标签；(5)将组建放到容器上；(6)为组件增加边框；(7)代码处理事件；(8)辅助技术支持。
4 问题分析
	本文主要将聚类分析应用在土壤样品选点中，不同地区土壤的色泽、土质、酸碱度、肥力和粘化性不同，因而可以选择出不同类别的土壤。通过对某地区土壤点的经度和纬度坐标点的采样，可以讲土壤分为四种土壤质，进行聚类分析，对每种土壤因地制宜。
本论文研究内容的应用需求：
(1) 对于给定的一组空间点位，包含五项属性（id，经度，纬度，海拔高度，土壤类型）；
(2) 需要提取样品数量中的5%为检测样品；
(3) 为了保证提取样品的代表性，提取原则是：①根据空间位置或经纬度坐标，最好选择中心点的样品；②每种土壤类型至少保证有一个样品；③每种土壤类型提取的样品数与该土壤类型的总数成比例。
5 算法设计及实现
5.1 算法描述和实现策略
5.1.1 算法描述
	本应用使用聚类算法中的K-means算法，具体的原理和实现流程见第2和第3中描述。
5.1.2 使用的编程语言与开发环境
	本文应用算法使用的语言是Java，辅助用Ant和Swing工具实现界面和聚类效果显示，开发环境使用jdk1.7.0_15。
5.2 应用的模块设计
5.2.1 算法模块图
 
图 5-2 K-Means算法在土壤选点中的应用
5.2.2 算法模块介绍
5.2.2.1 K-Means
该模块实现K-means算法。主要的函数和类：
public class K_Means；//数据结构定义与读取文件中原始数据
public void initial()；//初始化中心点(质心)
public void plus()； //
public void token()；//更改标志位(重新分配，看点属于哪个簇)
public void center()；//每聚类一次，求新的中心点
public void compare();//判断聚类是否结束
public void DuplicateCenter();//用新的簇中心替换旧的簇中心
public void WrietTxt();//将结果写到文件中
5.2.2.2 界面设计模块
该模块主要实现界面显示。主要的函数和类：
public class MyFrame;//定义本模块中的静态对象
public void paint();//画出边框和界面中的点
该模块实现基本界面的显示及重要的聚类效果的显示。聚类效果的显示能让使用者对聚类结果有一个感性的认识。
5.3 算法及代码实现
5.3.1 K-Means模块K-Means.java：
package Package;
import java.io.*;
public class K_Means {
	int Flags = 0;//标志聚类迭代是否结束
	int[] logo = new int[1200]; // 标志位
	double center_A[] = new double[2], center_B[] = new double[2],
			center_C[] = new double[2],center_D[] = new double[2],
			center_1[] = new double[2],center_2[] = new double[2], 
			center_3[] = new double[2],center_4[] = new double[2];
	double train[][] = new double[1200][2]; // 将对象实体化
/********************************************************************
	 * 读文件data0.txt中数据，保存至train[][]二维数组中
********************************************************************/
	public void readtxt() throws Exception {
		@SuppressWarnings("resource")
		BufferedReader br = new BufferedReader(new FileReader("d:/data0.txt"));
		String s;
		int i, j;
		i = 0;
		j = 0;
		while (br.ready())// 判断此流是否已准备好被读取
		{
			s = br.readLine();// 读文件中一行
			java.util.StringTokenizer tokenizer = new java.util.StringTokenizer(
					s, ",，");
//测试此 tokenizer的字符串中是否还有更多的可用标记
			while (tokenizer.hasMoreTokens())//
			{//将读入的字符串转化为双精度型数据
				train[i][j] = Double.parseDouble(tokenizer.nextToken());
				j++;
				if (j == 2) {
					j = 0;
					i++;
				}
			}
		}
	}

/*******************************************************************
	 *  初始化中心点(任意)	 ********************************************************************/
	public void initial() {
		for (int i = 0; i < 4; i++)
			// 初始化簇（旧）中心，不妨以前四个为中心
			for (int j = 0; j < 2; j++) {
				if (i == 0) {
					center_A[j] = train[i][j];
				} else if (i == 1) {
					center_B[j] = train[i][j];
				} else if (i == 2){
					center_C[j] = train[i][j];
				} else {
					center_D[j] = train[i][j];
				}
			}
		for (int j = 0; j < 2; j++)//初始化簇（新）中心
		{
			center_1[j] = center_2[j] = center_3[j] = center_4[j] = 0;
		}
		for (int i = 0; i < train.length; i++) {
			logo[i] = 0;// 初始化标志位
		}
	}

/********************************************************************
	 * 比较差值，确定所属类	 ********************************************************************/
	public void plus()// 求方差
	{
		for (int i = 0; i < train.length; i++) {
			double a, b, c, d;
			a = b = c = d= 0;
			for (int j = 0; j < 2; j++) {
				a += Math.pow((train[i][j] - center_A[j]), 2);
				b += Math.pow((train[i][j] - center_B[j]), 2);
				c += Math.pow((train[i][j] - center_C[j]), 2);
				d += Math.pow((train[i][j] - center_D[j]), 2);
			}
			token(a, b, c,d, i);// 标记logo[i] ，以logo=1,2,3表示所属类
		}
	}

/********************************************************************
	 * 更改标志位(重新分配，看点属于哪个簇)	 ********************************************************************/
	public void token(double a, double b, double c,double d, int i) {
		double temp = 0;
		if (a >= b && b>=c) {
			temp = c;
			this.logo[i] = 3;
		} else if(a>=b && c>=a){
			temp=b;
			this.logo[i]=2;
		} else {
			temp = a;
			this.logo[i] = 1;
		}
		if (temp >= d) {
			temp = d;
			this.logo[i] = 4;
		}
	}
/********************************************************************
	 * 每聚类一次，求一次新的中心点	 ********************************************************************/
	public void center() {
		int num1, num2, num3,num4;
		num1 = num2 = num3 =num4= 0;
		for (int j = 0; j < 2; j++) {
			center_1[j] = center_2[j] = center_3[j] =center_4[j]= 0;
		}
		for (int i = 0; i < train.length; i++) {
			switch (logo[i]) {
			case 1: {
				for (int j = 0; j < 2; j++) {
					center_1[j] += train[i][j];
				}
				num1++;
				break;
			}
			case 2: {
				for (int j = 0; j < 2; j++) {
					center_2[j] += train[i][j];
				}
				num2++;
				break;
			}
			case 3: {
				for (int j = 0; j < 2; j++) {
					center_3[j] += train[i][j];
				}
				num3++;
				break;
			}
			case 4: {
				for (int j = 0; j < 2; j++) {
					center_4[j] += train[i][j];
				}
				num4++;
				break;
			}
			}
		}
		for (int j = 0; j < 2; j++) {
			center_1[j] = (double) (center_1[j] / (double) num1);
			center_2[j] = (double) (center_2[j] / (double) num2);
			center_3[j] = (double) (center_3[j] / (double) num3);
			center_4[j] = (double) (center_4[j] / (double) num4);
		}
	}
/********************************************************************
	 * 判断聚类运算是否结束	 ********************************************************************/
	public void compare()// 新旧中心点
	{
		double a, b, c,d;
		a = b = c = d = 0;
		for (int j = 0; j < 2; j++ ) {
			a += Math.pow((center_1[j] - center_A[j]), 2);
			b += Math.pow((center_2[j] - center_B[j]), 2);
			c += Math.pow((center_3[j] - center_C[j]), 2);
			d += Math.pow((center_4[j] - center_D[j]), 2);
		}
		// 符合要求
		if ((a < 0.0000000000001) && (b < 0.0000000000001) && (c < 0.0000000000001) && (d < 0.0000000000001)) {
			Flags = 1;
		}
	}
/********************************************************************
	 * 用新的簇中心替换旧的簇中心	 ********************************************************************/
	public void DuplicateCenter() {
		for (int j = 0; j < 2; j++) {
			center_A[j] = center_1[j];
			center_B[j] = center_2[j];
			center_C[j] = center_3[j];
			center_D[j] = center_4[j];
		}
		;
	}
/********************************************************************
	 * 写文件到cluster_result.txt中
********************************************************************/
	public void WrietTxt() throws Exception {
		BufferedWriter bw = new BufferedWriter(new FileWriter(
				"d:/cluster_result.txt"));
		int i = 0;
		while (i < train.length) {
			String s = "";
			for (int j = 0; j < 2; j++) {
				s += "  " + String.valueOf(train[i][j]) + "  ";// 获得train[][]每一行数据，转化为字符串类型
			}
			;
			bw.write(s + String.valueOf(logo[i]));// 加入标志位
			bw.newLine();
			i++;
		}
		;
		bw.close();
	}
}
5.3.2 界面设计模块MyFrame.java：
package Package;
import java.awt.Color;
import java.awt.Graphics;
import javax.swing.JFrame;
import javax.swing.JPanel;
public class MyFrame extends JPanel {
	static K_Means kms = new K_Means();// 注意：定义静态对像,可用在静态方法里
	public MyFrame() {
	}
	// 重写paint方法
	public void paint(Graphics g) {
		// 设置画笔颜色
		g.setColor(Color.BLUE);
		// 画坐标
		g.drawLine(10, 10, 10, 550);
		g.setColor(Color.RED);
		g.drawString("经度", 15, 15);
		g.setColor(Color.BLUE);
		g.drawLine(10, 550, 750, 550);
		g.setColor(Color.RED);
		g.drawString("纬度", 750, 545);
		// 画点
		for (int i = 0; i < kms.train.length; i++) {
			if (kms.logo[i] == 1) {
				g.setColor(Color.RED);
				g.fillRect((int) kms.train[i][0] + 150, (int) kms.train[i][1],
						3, 3);		
			}
			if (kms.logo[i] == 2) {
				g.setColor(Color.BLUE);
				g.fillRect((int) kms.train[i][0] + 150, (int) kms.train[i][1],
						3, 3);		
			}
			if (kms.logo[i] == 3) {
				g.setColor(Color.GREEN);
				g.fillRect((int) kms.train[i][0] + 150,
						(int) kms.train[i][1], 3, 3);
			}
			if (kms.logo[i] == 4) {
				g.setColor(Color.black);
				g.fillRect((int) kms.train[i][0] + 150,
						(int) kms.train[i][1] + 20, 3, 3);
			}
		}
	}
	/**
	 *静态方法 
	 */
	public static void main(String[] args) {
		try {
			kms.readtxt();
		} catch (Exception e1) {
			System.out.print("文件读取成功……");
		}
		kms.initial();		
		kms.plus();		
		kms.center();		
		// 不停的循环
		while (kms.Flags == 0) {
			kms.DuplicateCenter();
			kms.plus();
			kms.center();
			kms.compare();
		}
		try {
			kms.WrietTxt();
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		K_Means kms = new K_Means();
		MyFrame jp = new MyFrame();
		// 窗体设置
		JFrame jf = new JFrame();
		// 将画布加入窗体
		jf.add(jp);
		jf.setTitle("K-Means算法在土壤样品选点中的应用");
		jf.setBounds(50, 50, 800, 600);
		// 关闭动作
		jf.setVisible(true);
		jf.setResizable(false);
		jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	}
}
5.4 界面设计显示
	将数据导入到文本文件data0.txt，点击编译、运行，聚类的结果在显示的界面中如图中所示，其中样本点数和聚类数分别用不同颜色显示：
 
图5-3 经、纬度点在图形界面中显示结果

本应用中采用的数据是某地区土壤点的经度和纬度坐标点，分为四种土壤质，为图5-3中四种颜色点，算法中分出所有点的土质类型。它的时间复杂度为0 (n k t ) , 其中, n 是所有对象的数目, k 是簇的数目, t 是迭代的次数。
6 总结与展望
6.1总结  
本文对聚类分析进行了一些介绍，并且重点分析了如何应用KM算法对平面空间上的点集进行划分。KM算法虽然简单高效，但同样也存在着一些不足。如该算法对初值敏感，对于不同的初值可能得到不同的聚类，在这方面的鲁棒性不强；该算法只有在均值被定义的情况下才能使用，这对于某些分类属性的数据对象来说较难实现。
6.2展望
鉴于这种算法各自的优缺点，以及为了适应现实社会的要求和想要取比传统的算法更好的聚类效果，很多在这些算法基础上的各种改进也不断涌现。并且随着数据挖掘技术与日常生活的关系越来越密切，各种各样聚类算法的实际应用也是研究者探索的一个重要方向。同时，每个聚类算法都面临着各自的问题，比如陷入局部最优、处理不了大数据或者对初始点太敏感等等。另外，由于算法太多，反而会让使用者不知道如何选择，也不知道哪些算法是适合于自己的实际数据的。所以说对于聚类方法还需要进行更深入的研究，针对以上这种聚类算法的一些缺陷，需要挖掘更多更具适应性的新型聚类算法。

参考文献
[1]	Margaret H. Dunham著，郭崇慧，田风占，靳晓明等译.数据挖掘教程.北京：清华大学出版社，2005.
[2]	戴晓燕，过仲阳，李勤奋，吴健平.空间聚类的研究现状及其应用[J]. 上海地质.2003,4.
[3]	马程.空间聚类研究[J]. 计算机技术与发展.2009,19(4).
[4]	彭丽.数据挖掘中几种划分聚类算法的比较及改进. 硕士论文.大连理工大学.2008.
[5]	席景科，谭海樵.空间聚类分析及评价方法[J].计算机工程与设计.2009,30 (7).
[6]	柳彦平，王文杰，谈恒贵.数据挖掘空间聚类. 计算机工程与应用.2005,35.
[7]	赵伟，张姝，李文辉.改进K-means的空间聚类算法[J]. 计算机应用研究.2008.1995-1997.


致谢
本研究及学位论文是在我的导师伍胜老师的亲切关怀和悉心指导下完成的。他严肃的科学态度，严谨的治学精神，精益求精的工作作风，深深地感染和激励着我。老师不仅在学业上给我以精心指导，同时还在思想、生活上给我以无微不至的关怀，在此谨向老师致以诚挚的谢意和崇高的敬意。我还要感谢在一起愉快的度过毕业论文小组的同学们，正是由于你们的帮助和支持，我才能克服一个一个的困难和疑惑，直至本文的顺利完成。
在论文即将完成之际，我的心情无法平静，从开始进入课题到论文的顺利完成，有多少可敬的师长、同学、朋友给了我无言的帮助，在这里请接受我诚挚的谢意!
最后我还要感谢培养我长大含辛茹苦的父母，谢谢你们!最后，再次对关心、帮助我的老师和同学表示衷心地感谢！



